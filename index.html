<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Modern Packing Puzzle</title>
    <style>
        :root {
            --cell-size: 38px;
            --gap: 3px; /* Gap between cells */
            --bg-color: #1a1a2e;
            --board-bg: #16213e;
            --board-cell: #0f3460;
            --text-color: #e94560;
            --accent: #e94560;
            --modal-bg: rgba(22, 33, 62, 0.95);
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-color);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            touch-action: none;
            user-select: none;
            overflow-x: hidden;
            min-height: 100vh;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 { margin: 0; font-weight: 700; color: white; letter-spacing: 1px; }
        p.subtitle { margin: 5px 0 0; color: #a0a0a0; font-size: 0.9rem; }

        #stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.05);
            padding: 10px 20px;
            border-radius: 50px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        #game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            width: 100%;
            max-width: 500px;
        }

        /* BOARD */
        #board-container {
            position: relative;
            padding: 10px;
            background: var(--board-bg);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            /* Prevent overflow on small screens */
            max-width: 100vw;
            box-sizing: border-box;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, var(--cell-size));
            grid-template-rows: repeat(8, var(--cell-size));
            gap: var(--gap);
        }

        .board-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background: var(--board-cell);
            border-radius: 4px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        /* INVENTORY */
        #inventory {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-content: flex-start;
            width: 100%;
            min-height: 200px;
            padding: 20px;
            background: rgba(255,255,255,0.03);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.05);
            box-sizing: border-box;
        }

        /* PIECES */
        .piece {
            position: relative;
            /* No background color for container! */
            display: grid;
            gap: var(--gap);
            cursor: grab;
            touch-action: none;
            z-index: 10;
            transition: transform 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            /* Padding ensures touch target is decent but doesn't affect visual layout */
            padding: 0; 
        }

        .piece.dragging {
            cursor: grabbing;
            z-index: 100;
            transform: scale(1.1);
            filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5));
            position: fixed; /* Fixed allows smooth drag outside containers */
            pointer-events: none; /* Let clicks pass through to detect drop targets */
        }
        
        .piece.invalid .piece-cell {
            background: #ff4757 !important; /* Red error color */
            box-shadow: 0 0 10px rgba(255, 71, 87, 0.6);
            opacity: 0.8;
            /* Striped pattern */
            background-image: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 5px,
                rgba(0,0,0,0.1) 5px,
                rgba(0,0,0,0.1) 10px
            );
        }

        .piece-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border-radius: 4px;
            box-shadow: inset 0 -2px 0 rgba(0,0,0,0.2), 0 2px 5px rgba(0,0,0,0.2);
            /* Colors set via inline style or specific class */
        }

        /* Unique Colors for Shapes */
        .color-black .piece-cell { background: #111; border: 1px solid #333; }
        .color-1 .piece-cell { background: #4cc9f0; } /* Cyan */
        .color-2 .piece-cell { background: #f72585; } /* Pink */
        .color-3 .piece-cell { background: #4361ee; } /* Blue */
        .color-4 .piece-cell { background: #7209b7; } /* Purple */
        .color-5 .piece-cell { background: #fee440; color: black; } /* Yellow */
        .color-6 .piece-cell { background: #06d6a0; } /* Green */
        .color-7 .piece-cell { background: #fb8500; } /* Orange */
        .color-8 .piece-cell { background: #ef476f; } /* Reddish */

        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .btn:active { transform: scale(0.96); }

        /* Modal */
        #message {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--modal-bg);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }
        
        #message h2 { font-size: 2.5rem; margin-bottom: 10px; color: #4cc9f0; }
        
        /* Mobile Scale */
        @media (max-width: 500px) {
            /* Dynamic calculation for cell size:
               (100vw - total_horizontal_padding) / 8 cells
               Padding breakdown: 20px body left + 20px body right + 10px board left + 10px board right = 60px
               Added extra safety margin (70px) to ensure no overflow
            */
            :root { 
                --cell-size: calc((100vw - 70px) / 8); 
                --gap: 2px; 
            }
            #game-area { width: 100%; }
        }
    </style>
</head>
<body>

    <header>
        <h1>BLOCK FIT</h1>
        <p class="subtitle">Tap to rotate. Drag to fit.</p>
    </header>
    
    <div id="stats">
        <span>‚è±Ô∏è <span id="timer">00:00</span></span>
        <span style="border-left: 1px solid rgba(255,255,255,0.2); padding-left: 20px;">üèÜ <span id="best-time">--:--</span></span>
    </div>

    <div id="game-area">
        <div id="board-container">
            <div id="board">
                <!-- 64 cells -->
            </div>
        </div>
        
        <div id="inventory">
            <!-- Pieces -->
        </div>
    </div>

    <button class="btn" onclick="initGame()">New Puzzle</button>

    <div id="message">
        <h2>SOLVED!</h2>
        <p>Time: <span id="final-time" style="font-weight:bold; font-size: 1.5rem;"></span></p>
        <button class="btn" style="background: white; color: #16213e;" onclick="closeModalAndRestart()">Play Again</button>
    </div>

<script>
    const BOARD_SIZE = 8;
    
    // Define pieces. We give each a color index.
    const PIECE_DEFS = [
        { id: 'b1', shape: [[1]], type: 'black', color: 'black' },
        { id: 'b2', shape: [[1, 1]], type: 'black', color: 'black' },
        { id: 'b3', shape: [[1, 1, 1]], type: 'black', color: 'black' },
        
        { id: 'p1', shape: [[1, 1, 1, 1]], type: 'play', color: '1' }, // 1x4
        { id: 'p2', shape: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], type: 'play', color: '2' }, // 3x4
        { id: 'p3', shape: [[1, 1, 1], [1, 1, 1], [1, 1, 1]], type: 'play', color: '3' }, // 3x3
        { id: 'p4', shape: [[1, 1, 1], [1, 1, 1]], type: 'play', color: '4' }, // 2x3
        { id: 'p5', shape: [[1, 1], [1, 1]], type: 'play', color: '5' }, // 2x2
        { id: 'p6', shape: [[1, 1, 1, 1, 1]], type: 'play', color: '6' }, // 1x5
        { id: 'p7', shape: [[1, 1], [1, 1], [1, 1], [1, 1], [1, 1]], type: 'play', color: '7' }, // 5x2
        { id: 'p8', shape: [[1, 1], [1, 1], [1, 1], [1, 1]], type: 'play', color: '8' } // 4x2
    ];

    let gameState = {
        timerStart: null,
        timerInterval: null,
        solved: false
    };

    const boardEl = document.getElementById('board');
    const inventoryEl = document.getElementById('inventory');
    const boardContainer = document.getElementById('board-container');

    // --- Init ---

    function initGame() {
        if (gameState.timerInterval) clearInterval(gameState.timerInterval);
        document.getElementById('timer').innerText = "00:00";
        document.getElementById('message').style.display = 'none';
        gameState.solved = false;

        // Reset UI
        boardEl.innerHTML = '';
        inventoryEl.innerHTML = '';

        // FIX: Remove existing pieces from the board container
        const existingPieces = boardContainer.querySelectorAll('.piece');
        existingPieces.forEach(p => p.remove());
        
        // Create grid cells
        for(let i=0; i<64; i++) {
            let cell = document.createElement('div');
            cell.className = 'board-cell';
            boardEl.appendChild(cell);
        }

        // Generate Level
        let success = false;
        let attempts = 0;
        while(!success && attempts < 20) {
            try { success = generateLevel(); } catch(e) {}
            attempts++;
        }
        
        if(!success) { alert("Generation failed. Trying again."); initGame(); return; }

        // Start Timer
        gameState.timerStart = Date.now();
        gameState.timerInterval = setInterval(updateTimer, 1000);
        updateBestTimeDisplay();
    }

    // --- Generator ---

    function generateLevel() {
        let logicalBoard = Array(8).fill().map(() => Array(8).fill(null));
        let genPieces = JSON.parse(JSON.stringify(PIECE_DEFS));
        // Sort larger pieces first for better backtracking success
        genPieces.sort((a,b) => (b.shape.length * b.shape[0].length) - (a.shape.length * a.shape[0].length));

        if (!solveBoard(logicalBoard, genPieces, 0)) return false;

        // Render Pieces
        genPieces.forEach(p => {
            let pos = findPiecePosition(logicalBoard, p.id);
            let pieceEl = createPieceElement(p);
            
            if (p.type === 'black') {
                placePieceOnBoardUI(pieceEl, pos.r, pos.c, p.placedShape, true);
                pieceEl.style.pointerEvents = 'none'; // Lock black pieces
            } else {
                // Randomly rotate initially
                if(Math.random() > 0.5) rotatePieceData(pieceEl);
                inventoryEl.appendChild(pieceEl);
                addInteraction(pieceEl, p.id);
            }
        });
        return true;
    }

    function solveBoard(board, pieces, pieceIndex) {
        if (pieceIndex >= pieces.length) return true;
        let p = pieces[pieceIndex];
        let uniqueShapes = [p.shape];
        let rotated = rotateMatrix(p.shape);
        if (JSON.stringify(rotated) !== JSON.stringify(p.shape)) uniqueShapes.push(rotated);

        let positions = [];
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) positions.push({r,c});
        positions.sort(() => Math.random() - 0.5);

        for (let shape of uniqueShapes) {
            for (let pos of positions) {
                if (canPlace(board, shape, pos.r, pos.c)) {
                    place(board, shape, pos.r, pos.c, p.id);
                    p.placedShape = shape; 
                    if (solveBoard(board, pieces, pieceIndex + 1)) return true;
                    remove(board, shape, pos.r, pos.c);
                }
            }
        }
        return false;
    }

    function canPlace(board, shape, r, c) {
        if (r + shape.length > 8 || c + shape[0].length > 8) return false;
        for(let i=0; i<shape.length; i++) {
            for(let j=0; j<shape[0].length; j++) {
                if (board[r+i][c+j] !== null) return false;
            }
        }
        return true;
    }

    function place(board, shape, r, c, id) {
        for(let i=0; i<shape.length; i++) {
            for(let j=0; j<shape[0].length; j++) {
                board[r+i][c+j] = id;
            }
        }
    }
    
    function remove(board, shape, r, c) {
        for(let i=0; i<shape.length; i++) {
            for(let j=0; j<shape[0].length; j++) {
                board[r+i][c+j] = null;
            }
        }
    }

    function rotateMatrix(matrix) {
        if(!matrix || !matrix.length) return matrix;
        return matrix[0].map((val, index) => matrix.map(row => row[index]).reverse());
    }

    function findPiecePosition(board, id) {
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) if(board[r][c] === id) return {r, c};
        return {r:0, c:0};
    }

    // --- UI Creation ---

    function createPieceElement(pData) {
        let el = document.createElement('div');
        el.className = `piece color-${pData.color}`;
        el.id = pData.id;
        
        let shape = pData.placedShape || pData.shape;
        renderPieceGrid(el, shape);
        return el;
    }

    function renderPieceGrid(el, shape) {
        // We set the CSS grid of the piece itself
        el.style.gridTemplateRows = `repeat(${shape.length}, 1fr)`;
        el.style.gridTemplateColumns = `repeat(${shape[0].length}, 1fr)`;
        el.dataset.matrix = JSON.stringify(shape);
        el.dataset.rows = shape.length;
        el.dataset.cols = shape[0].length;
        
        el.innerHTML = '';
        for(let r=0; r<shape.length; r++) {
            for(let c=0; c<shape[0].length; c++) {
                let cell = document.createElement('div');
                cell.className = 'piece-cell';
                el.appendChild(cell);
            }
        }
        // Force layout update for drag size
        updatePieceSize(el);
    }
    
    function updatePieceSize(el) {
        // Robust measurement: Measure a real cell on the board
        const sampleCell = boardEl.children[0];
        if(!sampleCell) return;
        
        const cellRect = sampleCell.getBoundingClientRect();
        // Use parseFloat from computed style for gap to be precise, or assume small int
        const root = getComputedStyle(document.documentElement);
        const gap = parseFloat(root.getPropertyValue('--gap')) || 3;
        
        const rows = parseInt(el.dataset.rows);
        const cols = parseInt(el.dataset.cols);
        
        const w = (cols * cellRect.width) + ((cols - 1) * gap);
        const h = (rows * cellRect.height) + ((rows - 1) * gap);
        
        el.style.width = w + 'px';
        el.style.height = h + 'px';
    }

    function placePieceOnBoardUI(el, r, c, shapeMatrix, isBlack) {
        // Alignment FIX: Use actual DOM elements to determine position
        // This avoids rounding errors from "38px" vs "10vw" calculations
        
        const targetIndex = r * 8 + c;
        const targetCell = boardEl.children[targetIndex];
        
        if(!targetCell) return;

        // Ensure element is in the container so relative offsets work
        boardContainer.appendChild(el);
        
        const cellRect = targetCell.getBoundingClientRect();
        const containerRect = boardContainer.getBoundingClientRect();
        
        // Exact relative position
        const left = cellRect.left - containerRect.left;
        const top = cellRect.top - containerRect.top;
        
        el.style.position = 'absolute';
        el.style.left = left + 'px';
        el.style.top = top + 'px';
        
        // Ensure size matches perfectly
        updatePieceSize(el);

        // Store logical position
        el.dataset.r = r;
        el.dataset.c = c;
    }

    // --- Interaction (Click & Drag) ---

    function addInteraction(el, id) {
        let isDragging = false;
        let startX, startY;
        let dragOffsetX, dragOffsetY;
        let dragThreshold = 5;
        let hasMoved = false;

        function start(e) {
            if (gameState.solved) return;
            // if e is touch, prevent default to stop scroll
            if (e.type === 'touchstart') e.preventDefault();
            
            const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
            const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
            
            startX = clientX;
            startY = clientY;
            hasMoved = false;
            isDragging = false;
            
            const rect = el.getBoundingClientRect();
            dragOffsetX = clientX - rect.left;
            dragOffsetY = clientY - rect.top;

            // Prepare for drag but don't start visual drag until move
            document.addEventListener('mousemove', move);
            document.addEventListener('touchmove', move, {passive: false});
            document.addEventListener('mouseup', end);
            document.addEventListener('touchend', end);
        }

        function move(e) {
            const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
            const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
            
            if (!isDragging) {
                // Check threshold
                if (Math.abs(clientX - startX) > dragThreshold || Math.abs(clientY - startY) > dragThreshold) {
                    isDragging = true;
                    startDrag(el, clientX, clientY);
                }
            }
            
            if (isDragging) {
                el.style.left = (clientX - dragOffsetX) + 'px';
                el.style.top = (clientY - dragOffsetY) + 'px';
            }
        }

        function startDrag(el, x, y) {
            el.classList.add('dragging');
            // Move to body for z-index dominance
            const rect = el.getBoundingClientRect();
            document.body.appendChild(el);
            el.style.position = 'fixed';
            el.style.left = (x - dragOffsetX) + 'px';
            el.style.top = (y - dragOffsetY) + 'px';
            el.style.width = rect.width + 'px';
            el.style.height = rect.height + 'px';
        }

        function end(e) {
            document.removeEventListener('mousemove', move);
            document.removeEventListener('touchmove', move);
            document.removeEventListener('mouseup', end);
            document.removeEventListener('touchend', end);

            if (!isDragging) {
                // It was a click -> Rotate
                handleRotation(el);
            } else {
                // Drop logic
                el.classList.remove('dragging');
                handleDrop(el);
            }
        }

        el.addEventListener('mousedown', start);
        el.addEventListener('touchstart', start, {passive: false});
    }

    function handleRotation(el) {
        rotatePieceData(el);
        // If on board, re-validate
        if (el.parentElement === boardContainer) {
            // Re-snap to current position to fix any size changes
            let r = parseInt(el.dataset.r);
            let c = parseInt(el.dataset.c);
            let matrix = JSON.parse(el.dataset.matrix);
            placePieceOnBoardUI(el, r, c, matrix, false);
            validateBoard();
        }
    }

    function handleDrop(el) {
        const boardRect = boardEl.getBoundingClientRect();
        const pieceRect = el.getBoundingClientRect();
        
        const centerX = pieceRect.left + pieceRect.width/2;
        const centerY = pieceRect.top + pieceRect.height/2;

        // Check if center is roughly inside board
        if (centerX > boardRect.left && centerX < boardRect.right &&
            centerY > boardRect.top && centerY < boardRect.bottom) {
            
            // Get sizing from real DOM elements to be precise
            const root = getComputedStyle(document.documentElement);
            const sampleCell = boardEl.children[0];
            const cellSize = sampleCell.getBoundingClientRect().width;
            const gap = parseFloat(root.getPropertyValue('--gap')) || 3;
            
            // Calculate grid index
            // Relative to board content box
            const relativeX = pieceRect.left - boardRect.left;
            const relativeY = pieceRect.top - boardRect.top;
            
            const col = Math.round(relativeX / (cellSize + gap));
            const row = Math.round(relativeY / (cellSize + gap));
            
            // Snap visual
            let matrix = JSON.parse(el.dataset.matrix);
            placePieceOnBoardUI(el, row, col, matrix, false);
            validateBoard();
        } else {
            // Return to inventory
            returnToInventory(el);
            validateBoard(); // Clear any red states from previous pos
        }
    }

    function returnToInventory(el) {
        el.style.position = 'relative';
        el.style.left = 'auto';
        el.style.top = 'auto';
        el.classList.remove('invalid');
        inventoryEl.appendChild(el);
        delete el.dataset.r;
        delete el.dataset.c;
    }

    function rotatePieceData(el) {
        let matrix = JSON.parse(el.dataset.matrix);
        let newMatrix = rotateMatrix(matrix);
        renderPieceGrid(el, newMatrix);
    }

    // --- Validation ---

    function validateBoard() {
        // We have to check all pieces in boardContainer
        const pieces = Array.from(boardContainer.children).filter(c => c.classList.contains('piece'));
        
        // 1. Build a map of grid usage
        let grid = Array(8).fill().map(() => Array(8).fill(0));
        let piecePositions = []; // Store {el, cells: [{r,c}]}
        
        pieces.forEach(p => {
            let r = parseInt(p.dataset.r);
            let c = parseInt(p.dataset.c);
            let matrix = JSON.parse(p.dataset.matrix);
            
            let cells = [];
            let isOutOfBounds = false;
            
            for(let i=0; i<matrix.length; i++) {
                for(let j=0; j<matrix[0].length; j++) {
                    let cellR = r + i;
                    let cellC = c + j;
                    
                    if (cellR >= 0 && cellR < 8 && cellC >= 0 && cellC < 8) {
                        grid[cellR][cellC]++;
                        cells.push({r: cellR, c: cellC});
                    } else {
                        isOutOfBounds = true;
                    }
                }
            }
            piecePositions.push({ el: p, cells, isOutOfBounds });
        });

        // 2. Mark invalid pieces
        let allValid = true;
        
        piecePositions.forEach(item => {
            let isInvalid = item.isOutOfBounds;
            
            // Check overlaps
            if (!isInvalid) {
                for(let cell of item.cells) {
                    if (grid[cell.r][cell.c] > 1) {
                        isInvalid = true;
                        break;
                    }
                }
            }
            
            if (isInvalid) {
                item.el.classList.add('invalid');
                allValid = false;
            } else {
                item.el.classList.remove('invalid');
            }
        });

        // 3. Check Win (Must use all pieces and be valid)
        // Total pieces = 11 (3 black + 8 play)
        // Inventory should be empty
        if (inventoryEl.children.length === 0 && allValid && pieces.length === PIECE_DEFS.length) {
            gameWon();
        }
    }

    function gameWon() {
        clearInterval(gameState.timerInterval);
        gameState.solved = true;
        let timeStr = document.getElementById('timer').innerText;
        document.getElementById('final-time').innerText = timeStr;
        document.getElementById('message').style.display = 'flex';
        
        // Save best
        let ms = Date.now() - gameState.timerStart;
        let currentBest = localStorage.getItem('blockFitBest');
        if (!currentBest || ms < parseInt(currentBest)) {
            localStorage.setItem('blockFitBest', ms);
            updateBestTimeDisplay();
        }
    }

    function closeModalAndRestart() {
        document.getElementById('message').style.display = 'none';
        initGame();
    }

    function updateTimer() {
        let delta = Date.now() - gameState.timerStart;
        let s = Math.floor(delta / 1000);
        let m = Math.floor(s / 60).toString().padStart(2, '0');
        let sec = (s % 60).toString().padStart(2, '0');
        document.getElementById('timer').innerText = `${m}:${sec}`;
    }
    
    function updateBestTimeDisplay() {
        const best = localStorage.getItem('blockFitBest');
        if(best) {
            let s = Math.floor(parseInt(best) / 1000);
            let m = Math.floor(s / 60).toString().padStart(2, '0');
            let sec = (s % 60).toString().padStart(2, '0');
            document.getElementById('best-time').innerText = `${m}:${sec}`;
        }
    }

    // Boot
    window.onload = initGame;

</script>
</body>
</html>
