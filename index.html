<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Modern Packing Puzzle</title>
    <style>
        :root {
            --cell-size: 38px;
            --gap: 3px; /* Gap between cells */
            --bg-color: #1a1a2e;
            --board-bg: #16213e;
            --board-cell: #0f3460;
            --text-color: #e94560;
            --accent: #e94560;
            --secondary-btn: rgba(255, 255, 255, 0.1);
            --modal-bg: rgba(22, 33, 62, 0.95);
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-color);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            touch-action: none;
            user-select: none;
            overflow-x: hidden;
            min-height: 100vh;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 { margin: 0; font-weight: 700; color: white; letter-spacing: 1px; }
        p.subtitle { margin: 5px 0 0; color: #a0a0a0; font-size: 0.9rem; }

        #stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.05);
            padding: 10px 20px;
            border-radius: 50px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        #game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            width: 100%;
            max-width: 500px;
        }

        /* BOARD */
        #board-container {
            position: relative;
            padding: 10px;
            background: var(--board-bg);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            /* Prevent overflow on small screens */
            max-width: 100vw;
            box-sizing: border-box;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, var(--cell-size));
            grid-template-rows: repeat(8, var(--cell-size));
            gap: var(--gap);
        }

        .board-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background: var(--board-cell);
            border-radius: 4px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        /* INVENTORY */
        #inventory {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-content: flex-start;
            width: 100%;
            min-height: 200px;
            padding: 20px;
            background: rgba(255,255,255,0.03);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.05);
            box-sizing: border-box;
        }

        /* PIECES */
        .piece {
            position: relative;
            display: grid;
            gap: var(--gap);
            cursor: grab;
            touch-action: none;
            z-index: 10;
            transition: transform 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            padding: 0; 
        }

        .piece.dragging {
            cursor: grabbing;
            z-index: 100;
            transform: scale(1.1);
            filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5));
            position: fixed;
            pointer-events: none;
        }
        
        .piece.invalid .piece-cell {
            background: #ff4757 !important;
            box-shadow: 0 0 10px rgba(255, 71, 87, 0.6);
            opacity: 0.8;
            background-image: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 5px,
                rgba(0,0,0,0.1) 5px,
                rgba(0,0,0,0.1) 10px
            );
        }

        .piece-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border-radius: 4px;
            box-shadow: inset 0 -2px 0 rgba(0,0,0,0.2), 0 2px 5px rgba(0,0,0,0.2);
        }

        /* Unique Colors for Shapes */
        .color-black .piece-cell { background: #111; border: 1px solid #333; }
        .color-1 .piece-cell { background: #4cc9f0; } /* Cyan */
        .color-2 .piece-cell { background: #f72585; } /* Pink */
        .color-3 .piece-cell { background: #4361ee; } /* Blue */
        .color-4 .piece-cell { background: #7209b7; } /* Purple */
        .color-5 .piece-cell { background: #fee440; color: black; } /* Yellow */
        .color-6 .piece-cell { background: #06d6a0; } /* Green */
        .color-7 .piece-cell { background: #fb8500; } /* Orange */
        .color-8 .piece-cell { background: #ef476f; } /* Reddish */

        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .btn:active { transform: scale(0.96); }

        .btn.secondary {
            background: var(--secondary-btn);
            box-shadow: none;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .btn.secondary:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Modals */
        #message, #input-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--modal-bg);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }
        
        #message h2, #input-modal h2 { font-size: 2.5rem; margin-bottom: 10px; color: #4cc9f0; }
        
        #code-input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-size: 1.5rem;
            text-align: center;
            text-transform: uppercase;
            margin: 20px 0;
            width: 180px;
            outline: none;
            font-family: monospace;
            letter-spacing: 2px;
        }
        #code-input:focus {
            border-color: var(--accent);
        }

        #footer-code {
            margin-top: 30px;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.2);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: monospace;
            cursor: pointer;
            transition: color 0.2s;
        }
        #footer-code:hover { color: rgba(255, 255, 255, 0.6); }

        /* Mobile Scale */
        @media (max-width: 500px) {
            :root { 
                --cell-size: calc((100vw - 70px) / 8); 
                --gap: 2px; 
            }
            #game-area { width: 100%; }
        }
    </style>
</head>
<body>

    <header>
        <h1>BLOCK FIT</h1>
        <p class="subtitle">Tap to rotate. Drag to fit.</p>
    </header>
    
    <div id="stats">
        <span>‚è±Ô∏è <span id="timer">00:00</span></span>
        <span style="border-left: 1px solid rgba(255,255,255,0.2); padding-left: 20px;">üèÜ <span id="best-time">--:--</span></span>
    </div>

    <div id="game-area">
        <div id="board-container">
            <div id="board">
                <!-- 64 cells -->
            </div>
        </div>
        
        <div id="inventory">
            <!-- Pieces -->
        </div>
    </div>
    
    <div id="footer-code" title="Click to copy puzzle link" onclick="copyFooterLink()">
        Puzzle: <span id="puzzle-code-display">---</span>
    </div>

    <div class="controls">
        <button class="btn secondary" onclick="openInputModal()">Load Puzzle</button>
        <button class="btn" onclick="initGame()">New Puzzle</button>
    </div>

    <!-- Win Modal -->
    <div id="message">
        <h2>SOLVED!</h2>
        <p>Time: <span id="final-time" style="font-weight:bold; font-size: 1.5rem;"></span></p>
        <div style="display: flex; gap: 10px;">
            <button class="btn" style="background: white; color: #16213e;" onclick="closeModalAndRestart()">Play Again</button>
            <button class="btn" style="background: #4cc9f0; color: #16213e;" onclick="shareResult()">Share Result</button>
        </div>
    </div>

    <!-- Input Modal -->
    <div id="input-modal">
        <h2>ENTER CODE</h2>
        <input type="text" id="code-input" maxlength="10" placeholder="CODE">
        <div style="display: flex; gap: 10px;">
            <button class="btn secondary" onclick="closeInputModal()">Cancel</button>
            <button class="btn" onclick="submitCode()">Load</button>
        </div>
    </div>

<script>
    const BOARD_SIZE = 8;
    
    const PIECE_DEFS = [
        { id: 'b1', shape: [[1]], type: 'black', color: 'black' },
        { id: 'b2', shape: [[1, 1]], type: 'black', color: 'black' },
        { id: 'b3', shape: [[1, 1, 1]], type: 'black', color: 'black' },
        
        { id: 'p1', shape: [[1, 1, 1, 1]], type: 'play', color: '1' },
        { id: 'p2', shape: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], type: 'play', color: '2' },
        { id: 'p3', shape: [[1, 1, 1], [1, 1, 1], [1, 1, 1]], type: 'play', color: '3' },
        { id: 'p4', shape: [[1, 1, 1], [1, 1, 1]], type: 'play', color: '4' },
        { id: 'p5', shape: [[1, 1], [1, 1]], type: 'play', color: '5' },
        { id: 'p6', shape: [[1, 1, 1, 1, 1]], type: 'play', color: '6' },
        { id: 'p7', shape: [[1, 1], [1, 1], [1, 1], [1, 1], [1, 1]], type: 'play', color: '7' },
        { id: 'p8', shape: [[1, 1], [1, 1], [1, 1], [1, 1]], type: 'play', color: '8' }
    ];

    let gameState = {
        timerStart: null,
        timerInterval: null,
        solved: false,
        currentCode: ''
    };

    const boardEl = document.getElementById('board');
    const inventoryEl = document.getElementById('inventory');
    const boardContainer = document.getElementById('board-container');
    const codeDisplay = document.getElementById('puzzle-code-display');

    // --- Boot ---
    window.onload = function() {
        const urlParams = new URLSearchParams(window.location.search);
        const code = urlParams.get('p');
        
        // Handle enter key in input
        document.getElementById('code-input').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') submitCode();
        });

        if (code) {
            initGame(code);
        } else {
            initGame();
        }
    };

    // --- Modal Logic ---
    function openInputModal() {
        document.getElementById('input-modal').style.display = 'flex';
        document.getElementById('code-input').value = '';
        setTimeout(() => document.getElementById('code-input').focus(), 100);
    }

    function closeInputModal() {
        document.getElementById('input-modal').style.display = 'none';
    }

    function submitCode() {
        const code = document.getElementById('code-input').value.trim().toUpperCase();
        if (code) {
            initGame(code);
            closeInputModal();
        }
    }

    // --- Init ---

    function initGame(forcedCode = null) {
        if (gameState.timerInterval) clearInterval(gameState.timerInterval);
        document.getElementById('timer').innerText = "00:00";
        document.getElementById('message').style.display = 'none';
        gameState.solved = false;

        // Reset UI
        boardEl.innerHTML = '';
        inventoryEl.innerHTML = '';
        
        const existingPieces = boardContainer.querySelectorAll('.piece');
        existingPieces.forEach(p => p.remove());
        
        // Create grid cells
        for(let i=0; i<64; i++) {
            let cell = document.createElement('div');
            cell.className = 'board-cell';
            boardEl.appendChild(cell);
        }

        let success = false;
        
        if (forcedCode) {
            // Load from code
            success = loadFromCode(forcedCode);
            if (!success) {
                alert("Invalid puzzle code! Generating a random puzzle instead.");
                window.history.replaceState({}, document.title, window.location.pathname);
                initGame(); // Retry random
                return;
            }
        } else {
            // Generate Random
            let attempts = 0;
            while(!success && attempts < 20) {
                try { success = generateLevel(); } catch(e) {}
                attempts++;
            }
            if(!success) { alert("Generation failed. Trying again."); initGame(); return; }
        }

        // Start Timer
        gameState.timerStart = Date.now();
        gameState.timerInterval = setInterval(updateTimer, 1000);
        updateBestTimeDisplay();
    }

    // --- Generator ---

    function generateLevel() {
        let logicalBoard = Array(8).fill().map(() => Array(8).fill(null));
        let genPieces = JSON.parse(JSON.stringify(PIECE_DEFS));
        genPieces.sort((a,b) => (b.shape.length * b.shape[0].length) - (a.shape.length * a.shape[0].length));

        if (!solveBoard(logicalBoard, genPieces, 0)) return false;

        // Render Pieces
        genPieces.forEach(p => {
            let pos = findPiecePosition(logicalBoard, p.id);
            let pieceEl = createPieceElement(p);
            
            if (p.type === 'black') {
                placePieceOnBoardUI(pieceEl, pos.r, pos.c, p.placedShape, true);
                pieceEl.style.pointerEvents = 'none'; // Lock black pieces
            } else {
                if(Math.random() > 0.5) rotatePieceData(pieceEl);
                inventoryEl.appendChild(pieceEl);
                addInteraction(pieceEl, p.id);
            }
        });
        
        // Update Code
        gameState.currentCode = encodePuzzleState();
        codeDisplay.innerText = gameState.currentCode;
        
        return true;
    }

    function loadFromCode(code) {
        const config = decodePuzzleState(code);
        if (!config) return false;

        gameState.currentCode = code;
        codeDisplay.innerText = code;

        // Place Black Pieces
        // B1
        let pB1 = PIECE_DEFS.find(p => p.id === 'b1');
        let elB1 = createPieceElement(pB1); 
        placePieceOnBoardUI(elB1, config.b1.r, config.b1.c, pB1.shape, true);
        elB1.style.pointerEvents = 'none';

        // B2
        let pB2 = PIECE_DEFS.find(p => p.id === 'b2');
        let elB2 = createPieceElement(pB2);
        if (config.b2.rot === 1) rotatePieceData(elB2);
        let currentShapeB2 = JSON.parse(elB2.dataset.matrix);
        placePieceOnBoardUI(elB2, config.b2.r, config.b2.c, currentShapeB2, true);
        elB2.style.pointerEvents = 'none';

        // B3
        let pB3 = PIECE_DEFS.find(p => p.id === 'b3');
        let elB3 = createPieceElement(pB3);
        if (config.b3.rot === 1) rotatePieceData(elB3);
        let currentShapeB3 = JSON.parse(elB3.dataset.matrix);
        placePieceOnBoardUI(elB3, config.b3.r, config.b3.c, currentShapeB3, true);
        elB3.style.pointerEvents = 'none';

        // Place Playable Pieces in Inventory
        PIECE_DEFS.filter(p => p.type === 'play').forEach(p => {
            let pieceEl = createPieceElement(p);
            if(Math.random() > 0.5) rotatePieceData(pieceEl);
            inventoryEl.appendChild(pieceEl);
            addInteraction(pieceEl, p.id);
        });

        return true;
    }

    // --- Encoding / Decoding ---
    
    function encodePuzzleState() {
        let val = 0;
        
        const getPieceInfo = (id) => {
            const el = document.getElementById(id);
            const r = parseInt(el.dataset.r);
            const c = parseInt(el.dataset.c);
            const rows = parseInt(el.dataset.rows);
            const cols = parseInt(el.dataset.cols);
            const rot = rows > cols ? 1 : 0;
            return { r, c, rot };
        };

        const b1 = getPieceInfo('b1');
        const b2 = getPieceInfo('b2');
        const b3 = getPieceInfo('b3');

        // B1 (6 bits)
        val |= (b1.r & 7);         
        val |= ((b1.c & 7) << 3);  

        // B2 (7 bits)
        val |= ((b2.r & 7) << 6);  
        val |= ((b2.c & 7) << 9);  
        val |= ((b2.rot & 1) << 12); 

        // B3 (7 bits)
        val |= ((b3.r & 7) << 13); 
        val |= ((b3.c & 7) << 16); 
        val |= ((b3.rot & 1) << 19); 

        return val.toString(36).toUpperCase();
    }

    function decodePuzzleState(code) {
        const val = parseInt(code, 36);
        if (isNaN(val)) return null;

        return {
            b1: {
                r: val & 7,
                c: (val >> 3) & 7
            },
            b2: {
                r: (val >> 6) & 7,
                c: (val >> 9) & 7,
                rot: (val >> 12) & 1
            },
            b3: {
                r: (val >> 13) & 7,
                c: (val >> 16) & 7,
                rot: (val >> 19) & 1
            }
        };
    }

    // --- Sharing ---

    function shareResult() {
        const time = document.getElementById('final-time').innerText;
        const code = gameState.currentCode;
        const url = window.location.href.split('?')[0] + '?p=' + code;
        
        const text = `üß© I solved Block Fit puzzle #${code} in ${time}!\n\nPlay it here: ${url}`;
        
        navigator.clipboard.writeText(text).then(() => {
            const btn = document.querySelector('#message button:last-child');
            const originalText = btn.innerText;
            btn.innerText = "Copied!";
            setTimeout(() => btn.innerText = originalText, 2000);
        }).catch(err => {
            prompt("Copy this link:", text);
        });
    }
    
    function copyFooterLink() {
         const code = gameState.currentCode;
         const url = window.location.href.split('?')[0] + '?p=' + code;
         navigator.clipboard.writeText(url).then(() => {
             const span = document.getElementById('puzzle-code-display');
             const originalText = span.innerText;
             span.innerText = "COPIED!";
             setTimeout(() => span.innerText = originalText, 1000);
         });
    }

    // --- Backtracking Solver ---

    function solveBoard(board, pieces, pieceIndex) {
        if (pieceIndex >= pieces.length) return true;
        let p = pieces[pieceIndex];
        let uniqueShapes = [p.shape];
        let rotated = rotateMatrix(p.shape);
        if (JSON.stringify(rotated) !== JSON.stringify(p.shape)) uniqueShapes.push(rotated);

        let positions = [];
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) positions.push({r,c});
        positions.sort(() => Math.random() - 0.5);

        for (let shape of uniqueShapes) {
            for (let pos of positions) {
                if (canPlace(board, shape, pos.r, pos.c)) {
                    place(board, shape, pos.r, pos.c, p.id);
                    p.placedShape = shape; 
                    if (solveBoard(board, pieces, pieceIndex + 1)) return true;
                    remove(board, shape, pos.r, pos.c);
                }
            }
        }
        return false;
    }

    function canPlace(board, shape, r, c) {
        if (r + shape.length > 8 || c + shape[0].length > 8) return false;
        for(let i=0; i<shape.length; i++) {
            for(let j=0; j<shape[0].length; j++) {
                if (board[r+i][c+j] !== null) return false;
            }
        }
        return true;
    }

    function place(board, shape, r, c, id) {
        for(let i=0; i<shape.length; i++) {
            for(let j=0; j<shape[0].length; j++) {
                board[r+i][c+j] = id;
            }
        }
    }
    
    function remove(board, shape, r, c) {
        for(let i=0; i<shape.length; i++) {
            for(let j=0; j<shape[0].length; j++) {
                board[r+i][c+j] = null;
            }
        }
    }

    function rotateMatrix(matrix) {
        if(!matrix || !matrix.length) return matrix;
        return matrix[0].map((val, index) => matrix.map(row => row[index]).reverse());
    }

    function findPiecePosition(board, id) {
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) if(board[r][c] === id) return {r, c};
        return {r:0, c:0};
    }

    // --- UI Helpers ---

    function createPieceElement(pData) {
        let el = document.createElement('div');
        el.className = `piece color-${pData.color}`;
        el.id = pData.id;
        
        let shape = pData.placedShape || pData.shape;
        renderPieceGrid(el, shape);
        return el;
    }

    function renderPieceGrid(el, shape) {
        el.style.gridTemplateRows = `repeat(${shape.length}, 1fr)`;
        el.style.gridTemplateColumns = `repeat(${shape[0].length}, 1fr)`;
        el.dataset.matrix = JSON.stringify(shape);
        el.dataset.rows = shape.length;
        el.dataset.cols = shape[0].length;
        
        el.innerHTML = '';
        for(let r=0; r<shape.length; r++) {
            for(let c=0; c<shape[0].length; c++) {
                let cell = document.createElement('div');
                cell.className = 'piece-cell';
                el.appendChild(cell);
            }
        }
        updatePieceSize(el);
    }
    
    function updatePieceSize(el) {
        const sampleCell = boardEl.children[0];
        if(!sampleCell) return;
        
        const cellRect = sampleCell.getBoundingClientRect();
        const root = getComputedStyle(document.documentElement);
        const gap = parseFloat(root.getPropertyValue('--gap')) || 3;
        
        const rows = parseInt(el.dataset.rows);
        const cols = parseInt(el.dataset.cols);
        
        const w = (cols * cellRect.width) + ((cols - 1) * gap);
        const h = (rows * cellRect.height) + ((rows - 1) * gap);
        
        el.style.width = w + 'px';
        el.style.height = h + 'px';
    }

    function placePieceOnBoardUI(el, r, c, shapeMatrix, isBlack) {
        const targetIndex = r * 8 + c;
        const targetCell = boardEl.children[targetIndex];
        
        if(!targetCell) return;

        boardContainer.appendChild(el);
        
        const cellRect = targetCell.getBoundingClientRect();
        const containerRect = boardContainer.getBoundingClientRect();
        
        const left = cellRect.left - containerRect.left;
        const top = cellRect.top - containerRect.top;
        
        el.style.position = 'absolute';
        el.style.left = left + 'px';
        el.style.top = top + 'px';
        
        updatePieceSize(el);

        el.dataset.r = r;
        el.dataset.c = c;
    }

    // --- Interaction ---

    function addInteraction(el, id) {
        let isDragging = false;
        let startX, startY;
        let dragOffsetX, dragOffsetY;
        let dragThreshold = 5;
        let hasMoved = false;

        function start(e) {
            if (gameState.solved) return;
            if (e.type === 'touchstart') e.preventDefault();
            
            const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
            const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
            
            startX = clientX;
            startY = clientY;
            isDragging = false;
            
            const rect = el.getBoundingClientRect();
            dragOffsetX = clientX - rect.left;
            dragOffsetY = clientY - rect.top;

            document.addEventListener('mousemove', move);
            document.addEventListener('touchmove', move, {passive: false});
            document.addEventListener('mouseup', end);
            document.addEventListener('touchend', end);
        }

        function move(e) {
            const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
            const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
            
            if (!isDragging) {
                if (Math.abs(clientX - startX) > dragThreshold || Math.abs(clientY - startY) > dragThreshold) {
                    isDragging = true;
                    startDrag(el, clientX, clientY);
                }
            }
            
            if (isDragging) {
                el.style.left = (clientX - dragOffsetX) + 'px';
                el.style.top = (clientY - dragOffsetY) + 'px';
            }
        }

        function startDrag(el, x, y) {
            el.classList.add('dragging');
            const rect = el.getBoundingClientRect();
            document.body.appendChild(el);
            el.style.position = 'fixed';
            el.style.left = (x - dragOffsetX) + 'px';
            el.style.top = (y - dragOffsetY) + 'px';
            el.style.width = rect.width + 'px';
            el.style.height = rect.height + 'px';
        }

        function end(e) {
            document.removeEventListener('mousemove', move);
            document.removeEventListener('touchmove', move);
            document.removeEventListener('mouseup', end);
            document.removeEventListener('touchend', end);

            if (!isDragging) {
                handleRotation(el);
            } else {
                el.classList.remove('dragging');
                handleDrop(el);
            }
        }

        el.addEventListener('mousedown', start);
        el.addEventListener('touchstart', start, {passive: false});
    }

    function handleRotation(el) {
        rotatePieceData(el);
        if (el.parentElement === boardContainer) {
            let r = parseInt(el.dataset.r);
            let c = parseInt(el.dataset.c);
            let matrix = JSON.parse(el.dataset.matrix);
            placePieceOnBoardUI(el, r, c, matrix, false);
            validateBoard();
        }
    }

    function handleDrop(el) {
        const boardRect = boardEl.getBoundingClientRect();
        const pieceRect = el.getBoundingClientRect();
        
        const centerX = pieceRect.left + pieceRect.width/2;
        const centerY = pieceRect.top + pieceRect.height/2;

        if (centerX > boardRect.left && centerX < boardRect.right &&
            centerY > boardRect.top && centerY < boardRect.bottom) {
            
            const root = getComputedStyle(document.documentElement);
            const sampleCell = boardEl.children[0];
            const cellSize = sampleCell.getBoundingClientRect().width;
            const gap = parseFloat(root.getPropertyValue('--gap')) || 3;
            
            const relativeX = pieceRect.left - boardRect.left;
            const relativeY = pieceRect.top - boardRect.top;
            
            const col = Math.round(relativeX / (cellSize + gap));
            const row = Math.round(relativeY / (cellSize + gap));
            
            let matrix = JSON.parse(el.dataset.matrix);
            placePieceOnBoardUI(el, row, col, matrix, false);
            validateBoard();
        } else {
            returnToInventory(el);
            validateBoard(); 
        }
    }

    function returnToInventory(el) {
        el.style.position = 'relative';
        el.style.left = 'auto';
        el.style.top = 'auto';
        el.classList.remove('invalid');
        inventoryEl.appendChild(el);
        delete el.dataset.r;
        delete el.dataset.c;
    }

    function rotatePieceData(el) {
        let matrix = JSON.parse(el.dataset.matrix);
        let newMatrix = rotateMatrix(matrix);
        renderPieceGrid(el, newMatrix);
    }

    function validateBoard() {
        const pieces = Array.from(boardContainer.children).filter(c => c.classList.contains('piece'));
        let grid = Array(8).fill().map(() => Array(8).fill(0));
        let piecePositions = []; 
        
        pieces.forEach(p => {
            let r = parseInt(p.dataset.r);
            let c = parseInt(p.dataset.c);
            let matrix = JSON.parse(p.dataset.matrix);
            
            let cells = [];
            let isOutOfBounds = false;
            
            for(let i=0; i<matrix.length; i++) {
                for(let j=0; j<matrix[0].length; j++) {
                    let cellR = r + i;
                    let cellC = c + j;
                    
                    if (cellR >= 0 && cellR < 8 && cellC >= 0 && cellC < 8) {
                        grid[cellR][cellC]++;
                        cells.push({r: cellR, c: cellC});
                    } else {
                        isOutOfBounds = true;
                    }
                }
            }
            piecePositions.push({ el: p, cells, isOutOfBounds });
        });

        let allValid = true;
        piecePositions.forEach(item => {
            let isInvalid = item.isOutOfBounds;
            if (!isInvalid) {
                for(let cell of item.cells) {
                    if (grid[cell.r][cell.c] > 1) {
                        isInvalid = true;
                        break;
                    }
                }
            }
            if (isInvalid) {
                item.el.classList.add('invalid');
                allValid = false;
            } else {
                item.el.classList.remove('invalid');
            }
        });

        if (inventoryEl.children.length === 0 && allValid && pieces.length === PIECE_DEFS.length) {
            gameWon();
        }
    }

    function gameWon() {
        clearInterval(gameState.timerInterval);
        gameState.solved = true;
        let timeStr = document.getElementById('timer').innerText;
        document.getElementById('final-time').innerText = timeStr;
        document.getElementById('message').style.display = 'flex';
        
        let ms = Date.now() - gameState.timerStart;
        let currentBest = localStorage.getItem('blockFitBest');
        if (!currentBest || ms < parseInt(currentBest)) {
            localStorage.setItem('blockFitBest', ms);
            updateBestTimeDisplay();
        }
    }

    function closeModalAndRestart() {
        window.history.replaceState({}, document.title, window.location.pathname);
        initGame();
    }

    function updateTimer() {
        let delta = Date.now() - gameState.timerStart;
        let s = Math.floor(delta / 1000);
        let m = Math.floor(s / 60).toString().padStart(2, '0');
        let sec = (s % 60).toString().padStart(2, '0');
        document.getElementById('timer').innerText = `${m}:${sec}`;
    }
    
    function updateBestTimeDisplay() {
        const best = localStorage.getItem('blockFitBest');
        if(best) {
            let s = Math.floor(parseInt(best) / 1000);
            let m = Math.floor(s / 60).toString().padStart(2, '0');
            let sec = (s % 60).toString().padStart(2, '0');
            document.getElementById('best-time').innerText = `${m}:${sec}`;
        }
    }

</script>
</body>
</html>
